Iterator:
	x Die node ids auf die offset array indizes setzen usw.

Dynamischer Graph:
	x Edge arrays immer nur setzen, indem durch das alte gegangen wird und die noch aktuellen Kanten gespeichert werden (Dadurch müssen die node_ids neu gesetzt werden, da sich die offsets ändern). Dann wohl am besten in vector.swap.
	x Methode die die node id's auf offset indizes setzt. tgt -> out_offset, src -> in_offset. (Vllt lieber die ganze Klasse umschreiben? Oder lieber wrapper Graph?)
	x Shortcuts alle in einem vector halten.
	x keine Listen!

ch_constructor:
	x independent set algo testen
	x contract zeugs schreiben

ch_constructor im Detail:
	x je nach Anzahl der eingehenden und ausgehenden Kanten vom kleineren aus aufzählen
	x Das Pfadchecken mit EdgeType als Parameter machen.
	x Nur für jeden center_node wird parallelisiert mit OpenMP
	x Das rausnehmen der Knoten genauso machen, wie schon im Pferd. ODER über die Anzahl!
		x Die zu findenden Knoten in einen vector machen. Ist shortcut, wenn der Knoten von dem wir kommen der center_node ist.
	x Doppelte Kanten nach jeder Runde prunen.
	x Shortcuts direkt einfügen mit mutex eben.
	x Manueller reset der Dijkstra vectors über Member var's vllt?

Graph umbauen:
	x Gleiche SCs prunen
	x Lösche Kanten die nichtmehr drin sind
	x Füge Kanten hinzu inkl. Shortcuts

Speedups:
	x Je nach Anzahl von eingehenden oder ausgehenden Kanten aus aufzählen.
	x Das ind. set aufbauen indem erst die Knoten mit #eingehend * #ausgehend sortiert werden. Dann vom kleinsten anfangen.


Fragen:

Zeugs:
	x getMaxNodeID() Zeugs und damit die Array Größe setzen.
	x is_deleted array im ch_constructor halten

Umbau:
	x Neue shortcuts sortieren
	x Dann edges und new_shortcuts mergen in einen neuen vector
	x Die edges die nicht reingemerged werden, weil rausgeschmissen kommen in dump vector

Neu:
	x Methode um CHGraph aufzubauen.
	x _in_edges vector auch manuell so mergen. (oder bringt das sowieso nix?)
	x CHDijkstra coden um zu schauen ob alle kürzesten Wege existieren.
	x Viele, viele Dijkstras laufen lassen um zu testen.
	x Die Level im CHGraph aufsetzen.

Noch neuer:
	x Testgraph erstellen inkl. Darstellung mit ipe um in Zukunft Tests laufen zu lassen, die ich auch noch manuell hinbekomme.

Noch noch neuer:
	x Doppelte SCs einer Runde löschen
	x Level im CHDijkstra berücksichtigen

Alle die noch offen sind:
	x Graphstats berechnen: Z.B. Was ist die Anzahl der Knoten mit Grad kleiner als 2,3,4?
	x Asserts zentral abschaltbar machen in defs.h
	x Init Methode für Graphen.
	x vector<bool> Bug beheben.
	x Preprocessing step: Knoten mit sowieso niedriger edge-difference kicken indem einfach alle SCs für die eingefügt werden. Besonders Grad 2/4 Knoten (Durchgangsknoten) können kontrahiert werden!
	x Wie machen wir das mit der edge difference?
		x Alle speichern aber eben davor vector reserve oder so machen. So macht's Stefan.
	x Arith. Mittel und SCs speichern.
	x Bug in quick contraction fixen. (gleiche edges)
	x graph info für ein bestimmtes set of nodes ausgeben.

Was noch:
	- Auf cmake umstellen oder so.
	- Auf allen vectors immer ein reserve machen
	- CHGraph und SCGraph Benennungen irgendwie konsistenter machen
	- Schnellen Iterator verwenden. (also den der mit den neuen IDS arbeitet)
	- Edges im CHGraph so sortieren, dass sie von großem nach kleinem Level gehen
	- das Sortieren der Kanten irgendwie zentral festlegen
	x child_edge auf NO_EID umstellen.

Stefan:
Makefile: (siehe paste)
  x s/LFLAGS/LDFLAGS/ ?
  x CC = g++ ? wirklich nötig? s/CC/CXX/
    .c files per default: $(CC) $(CPPFLAGS) $(CFLAGS) -c
    .cpp (.cc,.C) files: $(CXX) $(CPPFLAGS) $(CXXFLAGS) -c
  x $(BIN) hängt von main.o ab, aber kompiliert main.cpp nochmal
  x ist der sinn von $(BIN) *ein* binary zu benennen, oder potentiell mehrere?
    für mehrere ist $(BIN): $(OBJ) main.o nich so ne super regel :)
  x ein leeres OBJ zu verwenden ist overengineering...


x keine (inline) "header" implementierungen, wenn nich aufgrund von template absolutig nötig:
x nicht alle methoden gehören zu einem objekt (Edge::concat wäre global besser)
  x.swap(y) -> swap(x, y)
x evtl. alles in einen namespace - kostet wenig aufwand
x peformance: insbesondere bei längeren schleifen lohnt es vielleicht,
  die größe des vectors in ne lokale variable zu packen.
x evtl. eigene "assert_always" definieren; assert() ist ja nur für debugging da,
x manchmal kann man kleine checks aber auch im "release" aktiv haben.
	Antwort: Asserts können ruhig auch bei "release" drin bleiben.

nodes_and_edges.h:
x Parser_* klingt eher nach "private". Vllt. Detailed_* für ne public api.
x Parser/Serializer würde ich in n extra file packen.
  Z.bsp:
  Detailed_Node statt Parser_Node
  parser.h mit:
    readDetailedNode()
    readNode()
    readCHNode() ?
    write...
  Alternativ funktionen um Detailed_Node in andere Nodes zu konvertieren und zurück,
  darauf den serializer aufbauen.

  Die serialisierung ist nicht eine eigenschaft des objekts, sondern eines "formats";
  als ausnahme vllt. ne "debug" toString() methode oder so.

  (virtual write/read sieht jedenfalls komisch aus in kombination mit templates.)

- Node/Edge: "<" sind mit sehr spezieller semantik.
  du hast ja schon separate comparator klassen, nimm die
  "==" auf Edge kann man vermutlich lassen - (src,tgt) sollte unique sein.

x ist vererbung wirklich nötig? vermutlich hilfreich, wenn nicht:
    template<typename Node> struct CHNode { uint lvl; Node inner; }
    template<typename Edge> struct CHEdge { int child_edge_id[2]; Edge inner; }
  oder tatsächlich den inhalt kopieren.
  (man würde ja auch nicht ernsthaft vec3 von vec2 ableiten, das führt nur zu blöden
  fehlern, wo ein vec3 als vec2 verwendet wird, weils das typsystem erlaubt)

graph.h:
  x std::vector<T> mapped (u)int auf T, nicht andersrum:
    /* Maps edge id to index in the _out_edge vector. */
    std::vector<EdgeID> _id_to_index;
  - _next_id ist irgendwie "hässlich":
     a) _id_to_index.resize(_next_id); gehört in init(), _next_id nur als lokale variable.
     b) alternativ _next_id wenigstens in "edge_count" umbenennen
  x merge "public" api für sort*Edges, initOffsets, initIdToIndex:
    protected: void update();
    evtl. InEdgeSort/OutEdgeSort als class template parameter - gibts nen guten grund warum sich das ändern darf? oder nicht sowieso immer das gleiche ist (nach id?)
    da die klasse auf vererbung ausgelegt ist, sollte update() auch nicht public sein.
	Antwort: Ja, Knoten müssen anders sortiert sein während und nach der Kontraktion so wie ich das mache.
  x buildCHGraph:
    _in_edges.assign(_out_edges.begin(), _out_edges.end());
    _in_edges = _out_edges?
  x isUp:
    EdgeType implicit nach bool casten? oO
    evtl. return false durch nen assert() oder abort() ersetzen, solle ja nie vorkommen, oder?


chgraph.h:
- namen: SCGraph ?? das file heißt "chgraph", verwendet in ch_constructor.h mit typedef auf CHGraph...
- api docu: restructure() ? buildCHGraph() ?
