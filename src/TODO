Iterator:
	x Die node ids auf die offset array indizes setzen usw.

Dynamischer Graph:
	x Edge arrays immer nur setzen, indem durch das alte gegangen wird und die noch aktuellen Kanten gespeichert werden (Dadurch müssen die node_ids neu gesetzt werden, da sich die offsets ändern). Dann wohl am besten in vector.swap.
	x Methode die die node id's auf offset indizes setzt. tgt -> out_offset, src -> in_offset. (Vllt lieber die ganze Klasse umschreiben? Oder lieber wrapper Graph?)
	x Shortcuts alle in einem vector halten.
	x keine Listen!

ch_constructor:
	x independent set algo testen
	x contract zeugs schreiben

ch_constructor im Detail:
	x je nach Anzahl der eingehenden und ausgehenden Kanten vom kleineren aus aufzählen
	x Das Pfadchecken mit EdgeType als Parameter machen.
	x Nur für jeden center_node wird parallelisiert mit OpenMP
	x Das rausnehmen der Knoten genauso machen, wie schon im Pferd. ODER über die Anzahl!
		x Die zu findenden Knoten in einen vector machen. Ist shortcut, wenn der Knoten von dem wir kommen der center_node ist.
	x Doppelte Kanten nach jeder Runde prunen.
	x Shortcuts direkt einfügen mit mutex eben.
	- Auf allen vectors immer ein reserve machen
	- Wie machen wir das mit der edge difference?
		- Alle speichern aber eben davor vector reserve oder so machen. So macht's Stefan.
	(- Wie kann man auf die pq verzichen? <- Bringt's wahrscheinlich nicht so sehr.)
	x Manueller reset der Dijkstra vectors über Member var's vllt?

Graph umbauen:
	x Gleiche SCs prunen
	x Lösche Kanten die nichtmehr drin sind
	x Füge Kanten hinzu inkl. Shortcuts

Speedups:
	x Je nach Anzahl von eingehenden oder ausgehenden Kanten aus aufzählen.
	- Arith. Mittel und SCs speichern.
	x Das ind. set aufbauen indem erst die Knoten mit #eingehend * #ausgehend sortiert werden. Dann vom kleinsten anfangen.
	- Preprocessing step: Knoten mit sowieso niedriger edge-difference kicken indem einfach alle SCs für die eingefügt werden. Besonders Grad 2/4 Knoten (Durchgangsknoten) können kontrahiert werden!


Fragen:
- Was ist die Anzahl der Knoten mit Grad kleiner als 2,3,4?

Zeugs:
	- getMaxNodeID() Zeugs und damit die Array Größe setzen.
	x is_deleted array im ch_constructor halten

Umbau:
	x Neue shortcuts sortieren
	x Dann edges und new_shortcuts mergen in einen neuen vector
	x Die edges die nicht reingemerged werden, weil rausgeschmissen kommen in dump vector

Neu:
	- Methode um CHGraph aufzubauen.
	- _in_edges vector auch manuell so mergen. (oder bringt das sowieso nix?)
	- das Sortieren der Kanten irgendwie zentral festlegen
	- CHDijkstra coden um zu schauen ob alle kürzesten Wege existieren.
	- Viele, viele Dijkstras laufen lassen um zu testen.
	- Schnellen Iterator verwenden. (Was hab ich damit gemeint?)
	- Asserts zentral abschaltbar machen in defs.h
	- Edges im CHGraph so sortieren, dass sie von großem nach kleinem Level gehen
	- Die Level im CHGraph aufsetzen.

Noch neuer:
	- Testgraph erstellen inkl. Darstellung mit ipe um in Zukunft Tests laufen zu lassen, die ich auch noch manuell hinbekomme.
	- CHGraph und SCGraph Benennungen irgendwie konsistenter machen
